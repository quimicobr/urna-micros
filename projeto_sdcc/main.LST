C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include<reg52.h>
   2          
   3          //Gestão de timers:
   4          //TIMER0: uso geral (atraso,...)
   5          //TIMER1: exclusivo da serial
   6          //TIMER2: exclusivo do relógio
   7          
   8          ////////////////////////////////////////////////////////////
   9          //Arquivos .c incluidos no main para ser compilados no SDCC:
  10          ////////////////////////////////////////////////////////////
  11          //Primeiro: declaração de variáveis
  12          //Após: declaração de funções
  13          
  14          //VARIAVEIS
  15          
  16          
  17          //lcd.c
  18          sbit RS =P3^6;
  19          sbit E =P3^7;
  20          
  21          //teclado.c
  22          sbit C1 = P0^0; //coluna 1
  23          sbit C2 = P0^1;
  24          sbit C3 = P0^2;
  25          //sbit L1 = P0^4;   //linha 1
  26          //sbit L2 = P0^5;
  27          //sbit L3 = P0^6;
  28          //sbit L4 = P0^7;
  29          
  30          //serial.c
  31          #define NAO 0
  32          #define LE_N 1
  33          #define LE_PARAMETRO 2
  34          
  35          char fifo_recepcao[30];
  36          
  37          //buzzer.c
  38          sbit BUZZER = P3^3;
  39          
  40          //codigo_main.c
  41          char estado;
  42          #define NORMAL 0
  43          #define BLOQUEADA 1
  44          #define AUTONOMA 2 
  45          
  46          //Variaveis onde estará registrada a hora
  47          char hora = 0;
  48          char minuto = 0;
  49          char segundo = 0;
  50          char OLU = 0;
  51          
  52          // -- Flag que indica se o microcontrolador está esperando uma resposta do PC
  53          //No  momento que o microcontrolador envia um comando que precisa de resposta
  54          //essa flag é setada para 0. No momento que o computador responde, a flag
  55          //é setada para 1.
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 2   

  56          char respostaPC;
  57          #define OK 0
  58          #define PE 1
  59          #define PC 2 
  60          #define PT 3
  61          #define PS 4
  62          #define PG 5 
  63          #define PP 6 
  64          
  65          idata char pacote[30];
  66          
  67          char shora[3], sminuto[3];
  68          //char segundo_old = 0, minuto_old = 0, contEleitor=0, contPC=0;
  69          //char UA = 0; //urna autonoma
  70          char estado = 0;
  71          unsigned short cartao; //tem que ser long, mas a memoria estoura
  72          char urna_ativa = 1;
  73          
  74          char d[7];
  75          xdata struct {
  76            
  77            char nome[20];
  78            char partido[5];
  79            char nPartido[3];
  80            unsigned char nVotos;
  81            
  82            }presidente[10], governador[10], senador[10];
  83          
  84          short code codigo_eleitor [] = {262659, 206603, 244444, 216628, 262645,
  85                208221,
  86                262668,
  87                230357,
  88                262672,
  89                143293,
  90                245562,
  91                262686,
  92                264768,
  93                161948,
  94                262649,
  95                231423,
  96                230340,
  97                195149,
  98                231023,
  99                231035,
 100                221689,
 101                220149,
 102                264770,
 103                216625,
 104                262670,
 105                180669,
 106                262688,
 107                186103,
 108                230230,
 109                219839,
 110                243704,
 111                243716,
 112                275628,
 113                262543,
 114                275632,
 115                275631,
 116                275629,
 117                221433,
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 3   

 118                262542,
 119                275633,
 120                218776,
 121                216149,
 122                262539,
 123                207273,
 124                259797 };
 125          char c;
 126          
 127                
 128          //FUNCOES
 129          ////////////////////////////////////////////////////////////
 130          //lcd.c
 131          ////////////////////////////////////////////////////////////
 132          
 133          void atraso(){  
 134   1        
 135   1          TR0 = 0;
 136   1          TF0 = 0; //limpa a flag de estouro
 137   1          TMOD &= 0xF0;
 138   1          TMOD |= 0x02; //timer de 8 bits com recarga automática  
 139   1        //22,184 Mhz / 12 = 1,848 MHz (fTimer) -> Ttimer = 0,541 us
 140   1        // 40 us -> 74 ciclos - 256 - 74 ciclos = 182 -> valor a ser colocado no registrador
 141   1          TL0 = 182;
 142   1          TR0 = 1; //liga o timer
 143   1          while(TF0 == 0);
 144   1          TR0 = 0;
 145   1      }
 146          void atraso_clear(){  
 147   1        
 148   1          TR0 = 0;
 149   1          TF0 = 0; //limpa a flag de estouro
 150   1          TMOD &= 0xF0;
 151   1          TMOD |= 0x01;
 152   1         //22,184 Mhz / 12 = 1,848 MHz (fTimer) -> Ttimer = 0,541 us
 153   1         // 1650 us -> 3051 ciclos = 62485 (F415) -> valor a ser colocado no registrador
 154   1          TH0 = 0xF4;
 155   1          TL0 = 0x15;
 156   1          TR0 = 1; //liga o timer
 157   1          while(TF0 == 0);
 158   1          TR0 = 0;
 159   1      }       
 160          
 161          void escreve_comando(unsigned char com){
 162   1        
 163   1        RS = 0;
 164   1        P1 = com;
 165   1        E = 1;
 166   1        E = 0;
 167   1        atraso();
 168   1      }
 169          
 170          
 171          void LCD_init(){  
 172   1          
 173   1       escreve_comando(0x38);
 174   1       escreve_comando(0x38);
 175   1       escreve_comando(0x0E);
 176   1       escreve_comando(0x06);
 177   1       escreve_comando(0x01);
 178   1       atraso_clear();
 179   1      
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 4   

 180   1      }
 181          
 182          
 183          
 184              
 185          void escreve_LCD(char X){
 186   1            RS = 1;
 187   1            P1 = X;
 188   1      
 189   1            E = 1;
 190   1            atraso();
 191   1            E = 0;
 192   1          }
 193          
 194          
 195          void escreve_mensagem(char* mensagem){
 196   1        
 197   1        char i;
 198   1        for(i = 0; mensagem[i] != 0 ; i++){
 199   2          escreve_LCD(mensagem[i]); 
 200   2        }
 201   1        atraso();
 202   1        
 203   1      }
 204          
 205          void clear_lcd(){
 206   1        escreve_comando(0x01);
 207   1        atraso_clear();
 208   1      }
 209          
 210          ////////////////////////////////////////////////////////////
 211          //teclado.c
 212          ////////////////////////////////////////////////////////////
 213          
 214          
 215          void atraso_1m(){
 216   1        
 217   1        TR0 = 0;
 218   1        TF0 = 0; //limpa a flag de estouro  
 219   1        TMOD &= 0xF0;
 220   1        TMOD |= 0x02;
 221   1        //22,184 Mhz / 12 = 1,848 MHz (fTimer) -> Ttimer = 0,541 us
 222   1        // 1 ms -> 1844 ciclos -> 65536 - 1844 ciclos = 63692 -> valor a ser colocado no registrador
 223   1        TH0 = 0xF8; 
 224   1        TL0 = 0xCC;
 225   1        TR0 = 1; //liga o timer
 226   1        while(TF0 == 0);
 227   1      
 228   1      }
 229          
 230          char debouncing(char tecla){
 231   1        
 232   1        char i = 0;
 233   1        for (i = 0; i<=8; i++){
 234   2            
 235   2          if (P0 != tecla){
 236   3            return 0;
 237   3          }
 238   2          atraso_1m();
 239   2          
 240   2        }
 241   1        return 1;
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 5   

 242   1      
 243   1      }
 244          
 245          char varredura(){
 246   1        C1 = 0;
 247   1        C2 = 1;
 248   1        C3 = 1;
 249   1        switch(P0){
 250   2          case 0x7E:    //L1
 251   2            if(debouncing(0x7E))
 252   2              return '1';
 253   2          case 0xBE:    //L2
 254   2            if(debouncing(0xBE))
 255   2              return '4';
 256   2          case 0xDE:    //L3
 257   2            if(debouncing(0xDE))
 258   2              return '7';
 259   2          case 0xEE:    //L4
 260   2            if(debouncing(0xEE))
 261   2              return '*';
 262   2        }
 263   1        
 264   1        C1 = 1;
 265   1        C2 = 0;
 266   1        C3 = 1;
 267   1        switch(P0){
 268   2          case 0x7D:    //L1
 269   2            if(debouncing(0x7D))
 270   2              return '2';
 271   2          case 0xBD:    //L2
 272   2            if(debouncing(0xBD))
 273   2              return '5';
 274   2          case 0xDD:    //L3
 275   2            if(debouncing(0xDD))
 276   2              return '8';
 277   2          case 0xED:    //L4
 278   2            if(debouncing(0xED))
 279   2              return '0';
 280   2        }
 281   1        
 282   1        C1 = 1;
 283   1        C2 = 1;
 284   1        C3 = 0;
 285   1        switch(P0){
 286   2          case 0x7B:    //L1
 287   2            if(debouncing(0x7B))
 288   2              return '3';
 289   2          case 0xBB:    //L2
 290   2            if(debouncing(0xBB))
 291   2              return '6';
 292   2          case 0xDB:    //L3
 293   2            if(debouncing(0xDB))
 294   2              return '9';
 295   2          case 0xEB:    //L4
 296   2            if(debouncing(0xEB))
 297   2              return '#';
 298   2          }
 299   1        
 300   1        return '\0';
 301   1      }
 302          
 303          
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 6   

 304          char le_teclado(){
 305   1        
 306   1        static char tecla;
 307   1        char tecla_atual;
 308   1        tecla_atual = varredura();
 309   1          
 310   1          if(tecla_atual != tecla){
 311   2            tecla = tecla_atual;
 312   2          //  escreve_LCD(tecla);
 313   2          //  sound_buzzer_teclado();
 314   2            return tecla;
 315   2          }
 316   1        return '\0';
 317   1      }
 318          
 319          ////////////////////////////////////////////////////////////
 320          //myString.c
 321          ////////////////////////////////////////////////////////////
 322          
 323          char len_string(char* string){
 324   1        
 325   1        char i;
 326   1        for (i = 0; string[i] != '\0'; i++){}
 327   1        return i;
 328   1        
 329   1      }
 330          
 331          char maior(char arg1, char arg2){
 332   1        if (arg1 >arg2) return arg1;
 333   1        else return arg2;
 334   1      }
 335                
 336          char compara_string(char* string1,char* string2){
 337   1        
 338   1        //strings iguais retorna 1
 339   1        //strings diferentes retorna 0
 340   1        
 341   1        char i, out = 1;
 342   1        char lim;
 343   1        lim = maior(len_string(string1), len_string(string2));
 344   1        
 345   1        for (i = 0; i< lim; i++){
 346   2          
 347   2          if(string1[i] != string2[i]){
 348   3            return 0;
 349   3          }
 350   2        }
 351   1        return 1;
 352   1      } 
 353          
 354          void copia_string(char* alvo, char* valor){
 355   1        
 356   1        char i;
 357   1        for (i = 0; valor[i] != '\0'; i++) alvo[i] = valor[i];
 358   1      
 359   1      }
 360          
 361          void number_to_char(char* out, char in){
 362   1        
 363   1        if (in < 10){
 364   2          out[0] = 0;
 365   2          out[1] = in +48;
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 7   

 366   2        }
 367   1        else{
 368   2          out[0] = in%10 + 48;
 369   2          out[1] = in - (in%10)*10 + 48;
 370   2        }
 371   1        
 372   1      }
 373          
 374          
 375          void inicializa_string(char* string, char len){
 376   1        
 377   1        char i;
 378   1        for (i = 0; i<len; i++){
 379   2          string[i] = '\0';
 380   2        }
 381   1        
 382   1      }
 383          
 384          
 385          void clear_string(char* string){
 386   1        
 387   1        char i;
 388   1        for (i = 0; string[i] != '\0'; i++){
 389   2          string[i] = '\0';
 390   2        }
 391   1        
 392   1      }
 393          
 394          ////////////////////////////////////////////////////////////
 395          //serial.c
 396          ////////////////////////////////////////////////////////////
 397          
 398          void escreve_serial(char* mensagem){
 399   1      char i;
 400   1        for(i = 0; mensagem[i] != 0 ; i++){
 401   2          SBUF = mensagem[i];
 402   2          while(!TI);
 403   2          TI=0;
 404   2        }
 405   1      }
 406          
 407          void clear_FIFO(){
 408   1        char i;
 409   1        for (i = 0; fifo_recepcao[i] != '\0' && i<30; i++) fifo_recepcao[i] = '\0';
 410   1        
 411   1      }
 412          
 413          void le_parametros(){
 414   1        if(fifo_recepcao[0] == 'P'){
 415   2          switch(fifo_recepcao[1]){
 416   3            case('H'):
 417   3              hora = fifo_recepcao[2];
 418   3              minuto = fifo_recepcao[3];
 419   3              escreve_serial("MH");
 420   3              return;
 421   3              
 422   3            case('S'):
 423   3              if (respostaPC == PS){
 424   4                copia_string(pacote, fifo_recepcao);
 425   4                respostaPC = OK;
 426   4              }
 427   3              return;
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 8   

 428   3            case('G'):
 429   3              if (respostaPC == PG){
 430   4                copia_string(pacote, fifo_recepcao);
 431   4                respostaPC = OK;
 432   4              }
 433   3              return;
 434   3              
 435   3            case('P'):
 436   3              if (respostaPC == PP){
 437   4                copia_string(pacote, fifo_recepcao);
 438   4                respostaPC = OK;
 439   4              }
 440   3              return;
 441   3          }
 442   2        }
 443   1      }
 444          
 445          //Trata dados deve ler toda a mensagem mandada pela serial
 446          //Deve retornar o quanto mais deve ser lido nos casos em que a resposta do aplicativo
 447          //tem parâmatros junto
 448          char trata_dados(){
 449   1        
 450   1        if(fifo_recepcao[0] == 'P'){
 451   2          
 452   2          switch(fifo_recepcao[1]){
 453   3            case('L'):
 454   3              //Libera urna
 455   3              OLU = 1; //Ordem de Liberar Urna 
 456   3              escreve_serial("ML");
 457   3              return 0;
 458   3            case('B'):
 459   3              //Bloqueia urna
 460   3              OLU = 0; //Ordem de Liberar Urna
 461   3              escreve_serial("MB");
 462   3              return 0;
 463   3            case('H'):
 464   3              //Atualiza o horario
 465   3              //escreve_serial("MH");
 466   3              return 2;
 467   3            case('U'):
 468   3              //Envia boletim de urna
 469   3              return 0;
 470   3            case('E'):
 471   3              //Confirma entrada do eleitor
 472   3              if (respostaPC == PE){
 473   4                respostaPC = OK;
 474   4              }
 475   3              return 0;
 476   3            case('C'):
 477   3              //Confirma conclusão do voto
 478   3              if (respostaPC == PC){
 479   4                respostaPC = OK;
 480   4              }
 481   3              return 0;
 482   3            case('T'):
 483   3              //Confirma timeout do eleitor
 484   3              if (respostaPC == PT){
 485   4                respostaPC = OK;
 486   4              }
 487   3              return 0;
 488   3            case('S'):
 489   3              //Confirma envio do nome de senador
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 9   

 490   3              return -1;
 491   3            case('G'):
 492   3              //Confirma envio do nome de governador
 493   3              return -1;
 494   3            case('P'):
 495   3              //Confirma envio do nome de presidente
 496   3              return -1;
 497   3            default:
 498   3              return 0;
 499   3              
 500   3          }
 501   2        }
 502   1        return 0;
 503   1      }
 504          
 505          
 506          void configura_serial(){
 507   1        //configura o timer 1
 508   1        TMOD &= 0x0F;
 509   1        TMOD |= 0x20; //timer de 8 bits com recarga automática
 510   1        TL1 = 0xFD; //19200 bps
 511   1        TH1 = 0xFD; //recarga
 512   1        TR1 = 1; //liga o timer
 513   1        //configura a serial
 514   1        SCON = 0x50; //serial com freq variável + habilita recepcao
 515   1        EA = 1; //habilita as interrrupcoes do chip
 516   1        ES = 1; //habilita interrupcao da serial
 517   1      }
 518          
 519          void trata_interrupcao_serial() interrupt 4 { 
 520   1        static char pos = 0, l_final = 2, lendo_par = 0;
 521   1        char add;
 522   1        if(RI == 1){
 523   2          RI = 0;
 524   2          fifo_recepcao[pos] = SBUF;
 525   2          pos++;
 526   2          
 527   2          if(pos == l_final){
 528   3            //Aqui existem tres opções: se nao ha parametros a serem lidos, l_final continuara a mesmo
 529   3            //
 530   3            if (lendo_par == NAO){
 531   4              add = trata_dados();
 532   4              
 533   4              //Se trata_dados() mostra que não há mais bytes a serem lidos, limpa a FIFO e volta para 
 534   4              //a posição inicial
 535   4              if (add == 0){
 536   5                clear_FIFO();
 537   5                pos = 0;
 538   5                l_final = 2;
 539   5              }
 540   4              
 541   4              //Se trata_dados() envia o valor -1, isso quer dizer que a serial está esperando o valor 
 542   4              //n que indica o número de bytes a serem lidos
 543   4              else if(add == -1) {
 544   5                lendo_par = LE_N;
 545   5                l_final++;
 546   5              }
 547   4              
 548   4              //Se trata_dados() mostra que há mais bytes a serem lidos, adiciona o número de bytes 
 549   4              else{
 550   5                l_final += add;
 551   5                lendo_par = LE_PARAMETRO;
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 10  

 552   5              } 
 553   4            }
 554   3            else if (lendo_par == LE_N){
 555   4              add = fifo_recepcao[2];
 556   4              l_final += add;
 557   4              lendo_par = LE_PARAMETRO;
 558   4            }
 559   3            else if (lendo_par == LE_PARAMETRO){
 560   4              le_parametros();
 561   4              clear_FIFO();
 562   4              pos = 0;
 563   4              lendo_par = NAO;
 564   4              l_final = 2;
 565   4            }     
 566   3          }
 567   2        }
 568   1      }
 569          
 570          
 571          
 572          void solicita_senador(char* codigo){
 573   1        char mensagem[6];
 574   1        mensagem[0] = 'M';
 575   1        mensagem[1] = 'S';
 576   1        mensagem[2] = 2;
 577   1        mensagem[3] = codigo[0];
 578   1        mensagem[4] = codigo[1];
 579   1        mensagem[5] = '\0';
 580   1        respostaPC = PS;
 581   1        escreve_serial(mensagem);
 582   1      }
 583          
 584          void solicita_governador(char* codigo){
 585   1        char mensagem[6];
 586   1        mensagem[0] = 'M';
 587   1        mensagem[1] = 'G';
 588   1        mensagem[2] = 2;
 589   1        mensagem[3] = codigo[0];
 590   1        mensagem[4] = codigo[1];
 591   1        mensagem[5] = '\0';
 592   1        respostaPC = PG;
 593   1        escreve_serial(mensagem);
 594   1      }
 595          
 596          void solicita_presidente(char* codigo){
 597   1        char mensagem[6];
 598   1        mensagem[0] = 'M';
 599   1        mensagem[1] = 'P';
 600   1        mensagem[2] = 2;
 601   1        mensagem[3] = codigo[0];
 602   1        mensagem[4] = codigo[1];
 603   1        mensagem[5] = '\0';
 604   1        respostaPC = PP;
 605   1        escreve_serial(mensagem);
 606   1      }
 607          
 608          ////////////////////////////////////////////////////////////
 609          //relogio.c
 610          ////////////////////////////////////////////////////////////
 611          
 612          void configura_relogio(){
 613   1        T2CON = 0;
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 11  

 614   1        TL2 = 0;
 615   1        TH2 = 0x4C;
 616   1        RCAP2L = 0;
 617   1        RCAP2H = 0x4C;
 618   1        TR2 = 1;
 619   1        
 620   1        EA = 1; //habilita as interrrupcoes do chip
 621   1        ET2 = 1;  //habilita interrupcao da serial
 622   1      }
 623          
 624          void atualiza_relogio() interrupt 5 {
 625   1        
 626   1        static char count = 0;
 627   1        TF2 = 0;
 628   1      
 629   1        count ++;
 630   1        
 631   1        if (count >= 40){
 632   2          count = 0;
 633   2          segundo ++;
 634   2          if (segundo >= 60){
 635   3            segundo = 0;
 636   3            minuto ++;
 637   3            if (minuto >= 60){
 638   4              minuto = 0;
 639   4              if (hora >= 24){
 640   5                hora = 0;
 641   5              }
 642   4            }
 643   3          }
 644   2        }
 645   1        
 646   1        
 647   1      }
 648          
 649          
 650          ////////////////////////////////////////////////////////////
 651          //buzzer.c
 652          ////////////////////////////////////////////////////////////
 653          
 654          void sound_buzzer_teclado(){
 655   1        
 656   1        //Nota medida: C#7 - 2217.46 Hz = 831 ciclos do timer
 657   1        //Valor do timer: FCC1
 658   1        short int i = 0;
 659   1        TR0 = 0;
 660   1        TF0 = 0; //limpa a flag de estouro
 661   1        TMOD &= 0xF0;
 662   1        TMOD |= 0x01; //timer de 16 bits 
 663   1        TH0 = 0xFC;
 664   1        TL0 = 0xC1;
 665   1        TR0 = 1; //liga o timer
 666   1        BUZZER = 0;
 667   1        for(i = 0;i < 100; i++){
 668   2          while(TF0 == 0);
 669   2          TH0 = 0xFC;
 670   2          TL0 = 0xC1;
 671   2          TF0 = 0;
 672   2          BUZZER = !BUZZER; 
 673   2        }
 674   1      }
 675            
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 12  

 676          void sound_buzzer_voto(){
 677   1        
 678   1        //Notas: C#7 e C7 
 679   1        //C7 - 2093Hz = 881 ciclos do timer - FC8F
 680   1        //C#7 - 2217.46 Hz = 831 ciclos do timer - FCC1
 681   1      
 682   1        short int i;
 683   1        char n;
 684   1        TR0 = 0;
 685   1        TF0 = 0; //limpa a flag de estouro
 686   1        TMOD &= 0xF0;
 687   1        TMOD |= 0x01; //timer de 16 bits 
 688   1        TH0 = 0xFC;
 689   1        TL0 = 0xC1;
 690   1        TR0 = 1; //liga o timer
 691   1        BUZZER = 0;
 692   1        for (n = 0; n<4; n++){
 693   2          
 694   2          for (i = 0; i < 300; i++){    
 695   3            while(TF0 == 0);
 696   3            TH0 = 0xFC;
 697   3            TL0 = 0xC1;
 698   3            TF0 = 0;
 699   3            BUZZER = !BUZZER;
 700   3          }
 701   2          
 702   2          for (i = 0; i < 300; i++){    
 703   3            while(TF0 == 0);
 704   3            TH0 = 0xFC;
 705   3            TL0 = 0x8F;
 706   3            TF0 = 0;
 707   3            BUZZER = !BUZZER;
 708   3          }
 709   2        }
 710   1      }
 711          
 712          ////////////////////////////////////////////////////////////
 713          //codigo_main.c
 714          ////////////////////////////////////////////////////////////
 715          
 716          void configura_serial();
 717          
 718          void clear_pacote(){
 719   1        
 720   1        char i;
 721   1        for (i = 0; pacote[i] != '\0' && i<30; i++){
 722   2          pacote[i] = '\0';
 723   2        }
 724   1          
 725   1      }
 726          
 727          void varredura_candidatos(){
 728   1        
 729   1        char d0, d1;
 730   1        char d[3];
 731   1        char comprimento, i, inicio_par;
 732   1        char nome[20];
 733   1        char partido[5];
 734   1        char pos_sen = 0, pos_gov = 0, pos_pres = 0;
 735   1      
 736   1        for (d0 = '0'; d0 <= '1'; d0++){
 737   2          
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 13  

 738   2          d[0] = d0;
 739   2          for (d1 = '0'; d1 <= '9'; d1++){
 740   3            
 741   3            d[1] = d1;
 742   3            d[2] = '\0';
 743   3            // ---------------------------
 744   3            solicita_senador(d);
 745   3            while (respostaPC != OK);
 746   3            //Pega o dado do senador e ve se nao é nulo
 747   3            //Se não for, armazena no vetor de struct
 748   3            
 749   3            comprimento = pacote[2];
 750   3            
 751   3            for (i = 0; pacote[i+3] != ' ' ; i++){
 752   4              nome[i] = pacote[i+3];
 753   4            }
 754   3            inicio_par = i + 1; 
 755   3            for (i = 0; pacote[i+inicio_par] != '\0'; i++){
 756   4              partido[i] = pacote[i+inicio_par];
 757   4            }
 758   3            
 759   3            
 760   3            if(!compara_string(nome,"NULO")){
 761   4              copia_string(senador[pos_sen].nome, nome);
 762   4              copia_string(senador[pos_sen].partido, partido);
 763   4              copia_string(senador[pos_sen].nPartido, d);
 764   4            }
 765   3            clear_string(pacote);
 766   3            clear_string(nome);
 767   3            clear_string(partido);
 768   3            // ---------------------------
 769   3            solicita_governador(d);
 770   3            
 771   3            while (respostaPC != OK);
 772   3            //Pega o dado do senador e ve se nao é nulo
 773   3            //Se não for, armazena no vetor de struct
 774   3            comprimento = pacote[2];
 775   3            
 776   3            for (i = 0; pacote[i+3] != ' '; i++){
 777   4              nome[i] = pacote[i+3];
 778   4            }
 779   3            inicio_par = i + 1; 
 780   3            for (i = 0; pacote[i+inicio_par] != '\0'; i++){
 781   4              partido[i] = pacote[i+inicio_par];
 782   4            }
 783   3            
 784   3            clear_pacote();
 785   3            
 786   3            if(!compara_string(nome,"NULO")){
 787   4              copia_string(governador[pos_sen].nome, nome);
 788   4              copia_string(governador[pos_sen].partido, partido);
 789   4              copia_string(governador[pos_sen].nPartido, d);
 790   4            }
 791   3            
 792   3            // ---------------------------
 793   3            solicita_presidente(d);
 794   3            
 795   3            while (respostaPC != OK);
 796   3            //Pega o dado do senador e ve se nao é nulo
 797   3            //Se não for, armazena no vetor de struct
 798   3            comprimento = pacote[2];
 799   3            
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 14  

 800   3            for (i = 0; pacote[i+3] != ' '; i++){
 801   4              nome[i] = pacote[i+3];
 802   4            }
 803   3            inicio_par = i + 1; 
 804   3            for (i = 0; pacote[i+inicio_par] != '\0'; i++){
 805   4              partido[i] = pacote[i+inicio_par];
 806   4            }
 807   3            
 808   3            clear_pacote();
 809   3            
 810   3            if(!compara_string(nome,"NULO")){
 811   4              copia_string(presidente[pos_sen].nome, nome);
 812   4              copia_string(presidente[pos_sen].partido, partido);
 813   4              copia_string(presidente[pos_sen].nPartido, d);
 814   4            }
 815   3      
 816   3          } 
 817   2        }
 818   1      }
 819          
 820          void envia_boletim(){
 821   1        
 822   1        char i;
 823   1        char votos[3];
 824   1        
 825   1        for (i = 0; i<10; i++){
 826   2          
 827   2          
 828   2          escreve_serial("Senador: {");
 829   2          
 830   2          if(compara_string(senador[i].nome, "")){
 831   3            
 832   3            escreve_serial("(");
 833   3            escreve_serial(senador[i].nome);
 834   3            escreve_serial(",");
 835   3            number_to_char(votos,senador[i].nVotos);
 836   3            escreve_serial(votos);
 837   3            escreve_serial(") ");
 838   3            
 839   3          }
 840   2          
 841   2          escreve_serial("} Governador: {");
 842   2          
 843   2          if(compara_string(governador[i].nome, "")){
 844   3            
 845   3            escreve_serial("(");
 846   3            escreve_serial(governador[i].nome);
 847   3            escreve_serial(",");
 848   3            number_to_char(votos,governador[i].nVotos);
 849   3            escreve_serial(votos);
 850   3            escreve_serial(") ");
 851   3            
 852   3          }
 853   2          
 854   2          escreve_serial("} Presidente: {");
 855   2          
 856   2          if(compara_string(presidente[i].nome, "")){
 857   3            
 858   3            escreve_serial("(");
 859   3            escreve_serial(presidente[i].nome);
 860   3            escreve_serial(",");
 861   3            number_to_char(votos,presidente[i].nVotos);
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 15  

 862   3            escreve_serial(votos);
 863   3            escreve_serial(") ");
 864   3            
 865   3          }
 866   2          
 867   2          escreve_serial("}");
 868   2        }
 869   1      }
 870          
 871          void inicializa_structs(){
 872   1        
 873   1        char i;
 874   1        for(i = 0; i<10; i++){
 875   2          
 876   2          inicializa_string(senador[i].nome, 20);
 877   2          inicializa_string(senador[i].partido, 5);
 878   2          inicializa_string(senador[i].nPartido, 3);
 879   2          senador[i].nVotos = 0;
 880   2          
 881   2          inicializa_string(governador[i].nome, 20);
 882   2          inicializa_string(governador[i].partido, 5);
 883   2          inicializa_string(governador[i].nPartido, 3);
 884   2          governador[i].nVotos = 0;
 885   2          
 886   2          inicializa_string(presidente[i].nome, 20);
 887   2          inicializa_string(presidente[i].partido, 5);
 888   2          inicializa_string(presidente[i].nPartido, 3);
 889   2          presidente[i].nVotos = 0;
 890   2          
 891   2        }
 892   1        
 893   1      }
 894          
 895          char le_numero(char n){
 896   1        static char i=0;
 897   1        char c;
 898   1        c = le_teclado();
 899   1          if(c != 0){
 900   2            if(i<n){
 901   3            escreve_LCD(c);
 902   3            d[i] = c;
 903   3            i++;
 904   3            }else{
 905   3                  i = 0;
 906   3                  return 1; //para 
 907   3                 }
 908   2          }
 909   1        return 0; // continua
 910   1      }
 911          
 912          
 913          void transicao_estado(char et){
 914   1        switch(et){
 915   2          case 0: clear_lcd();
 916   2                  escreve_mensagem("N de cartao?");
 917   2                  clear_string(d);
 918   2                  estado = 0;
 919   2                  break;
 920   2          
 921   2          case 1: clear_lcd();
 922   2                  escreve_mensagem("N de senador?");
 923   2                  clear_string(d);
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 16  

 924   2                  estado = 1;
 925   2                  break;
 926   2          
 927   2          case 2: clear_lcd();
 928   2                  escreve_mensagem("N de govern.?");
 929   2                  clear_string(d);
 930   2                  estado = 2;
 931   2                  break;
 932   2          
 933   2          case 3: clear_lcd();
 934   2                  escreve_mensagem("N de pres.?");
 935   2                  clear_string(d);
 936   2                  estado = 3;
 937   2                  break;
 938   2                  
 939   2          case 4: clear_lcd();
 940   2                  escreve_mensagem("FIM!!!");
 941   2                  clear_string(d);
 942   2                  estado = 4;
 943   2                  break;
 944   2          
 945   2          default: break;
 946   2        }
 947   1      }
 948          
 949          void main(){
 950   1      
 951   1        configura_serial();
 952   1      //  configura_relogio();
 953   1        
 954   1        //Inicializa o visor LCD
 955   1        LCD_init();
 956   1        clear_lcd();
 957   1        clear_string(d);
 958   1        //escreve_mensagem("Inicializando...");
 959   1        
 960   1        //inicializa_structs();
 961   1        //clear_pacote();
 962   1        //solicita_senador("13");
 963   1        
 964   1      
 965   1      
 966   1        while(1){
 967   2          
 968   2          //envia sinal de vida para o PC todos os segundos
 969   2      //    if(segundo_old != segundo){
 970   2      //      escreve_serial("MO");
 971   2      //      segundo_old = segundo;
 972   2      //    }
 973   2          
 974   2          //bloqueia urna
 975   2          if((hora>=17 || hora<8 || OLU == 0) && urna_ativa != 0){
 976   3            clear_lcd();
 977   3            escreve_mensagem("Urna Bloqueada");
 978   3            urna_ativa = 0;
 979   3          }
 980   2          
 981   2          //libera a urna 
 982   2          if(hora<17 && hora >= 8 && OLU == 1 && urna_ativa != 1){
 983   3            urna_ativa = 1;
 984   3            transicao_estado(0);
 985   3          }
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 17  

 986   2          
 987   2          if(urna_ativa){
 988   3            //leitura do cartao
 989   3            
 990   3          switch(estado){
 991   4            case 0: if(le_numero(2)){ //tem que ser 6, mas a memoria estoura        
 992   5                    //cartao = (d[0]- '0')*100000 + (d[1]- '0')*10000 + (d[2]- '0')*1000 + (d[3]- '0')*100 + (d[4]- '0'
             -)*10 + (d[5]- '0')*1;           
 993   5                    cartao = (d[0]- '0')*10 + (d[1]- '0')*1;
 994   5                    transicao_estado(1);
 995   5                    }   
 996   4                    break;
 997   4            
 998   4            case 1: if(le_numero(2)){ 
 999   5                    solicita_senador(d);
1000   5                    transicao_estado(2);
1001   5                    }
1002   4                    break;
1003   4                    
1004   4            case 2: if(le_numero(2)){ 
1005   5                    solicita_governador(d);
1006   5                    transicao_estado(3);
1007   5                    }
1008   4                    break;
1009   4                    
1010   4            case 3: if(le_numero(2)){ 
1011   5                    solicita_presidente(d);
1012   5                    transicao_estado(4);
1013   5                    }
1014   4                    break;  
1015   4                    
1016   4            case 4:  if(le_teclado())
1017   4                      transicao_estado(0);
1018   4                     break;
1019   4            
1020   4            default: break;
1021   4                      
1022   4          }
1023   3              
1024   3          }
1025   2        }
1026   1      }
1027          
1028          //    c = le_teclado();
1029          //    if(c != 0){   
1030          //      if(c == '0'){
1031          //      shora[0] = (hora / 10) + '0';
1032          //      shora[1] = (hora % 10) + '0';
1033          //          
1034          //      sminuto[0] = (minuto / 10) + '0';
1035          //      sminuto[1] = (minuto % 10) + '0';
1036          //          
1037          //      clear_lcd();
1038          //      escreve_mensagem(shora);
1039          //      escreve_mensagem(":");
1040          //      escreve_mensagem(sminuto);
1041          //      
1042          //      sound_buzzer_teclado(); 
1043          //      }
1044          //      if(c == '*')
1045          //          clear_lcd();
1046          //      if(c == '#')
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 18  

1047          //          escreve_LCD(OLU + '0');
1048          
1049          
1050          
1051            
1052          //    c = le_teclado();
1053          //    if(c != 0){   
1054          //    shora[0] = (hora / 10) + '0';
1055          //    shora[1] = (hora % 10) + '0';
1056          //        
1057          //    sminuto[0] = (minuto / 10) + '0';
1058          //    sminuto[1] = (minuto % 10) + '0';
1059          //        
1060          //    clear_lcd();
1061          //    escreve_mensagem(shora);
1062          //    escreve_mensagem(":");
1063          //    escreve_mensagem(sminuto);
1064          //    
1065          //    sound_buzzer_teclado(); 
1066          //    if(c == '*')
1067          //        clear_lcd();
1068          //  }
1069          
1070          
1071          
1072          
1073          
1074              //admistração dos timeouts  
1075          //    if(resposta_PC == OK){
1076          //      contPC = 0;
1077          //      UA = 0;
1078          //    }
1079          //    if(minuto_old != minuto){
1080          //      contEleitor++;
1081          //      contPC++;
1082          //        if(contPC >=3)
1083          //          UA = 1;
1084          //      minuto_old = minuto;
1085          //    }
1086                
1087          
1088          
1089            /*
1090            while(1){
1091          
1092              c = le_teclado;
1093              
1094                if(c != 0){
1095                  
1096                  //escreve no lcd o horario
1097                  
1098                  /*
1099                  
1100                  shora[1] = (hora / 10) + '0';
1101                  shora[0] = (hora % 10) + '0';
1102                  shora[2] = 0;
1103                  
1104                  sminuto[1] = (minuto / 10) + '0';
1105                  sminuto[0] = (minuto % 10) + '0';
1106                  sminuto[2] = 0;
1107                  
1108                  clear_lcd();
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 19  

1109                  escreve_mensagem(shora);
1110                  escreve_mensagem(":");
1111                  escreve_mensagem(sminuto);
1112                    */
1113          //          escreve_LCD(c);
1114                    
1115          //      }
1116                
1117          //    if(((hora>=17 || hora < 8) || !OLU) && estado != 0) 
1118          //      transicao_estado(0); //bloqueia a urna
1119          
1120          //    switch(estado){
1121          //    
1122          //      case 0: //urna bloqueada
1123          //        if(OLU && hora<17 && hora>= 8)
1124          //          transicao_estado(1);  
1125          //        break;
1126          
1127          //      case 1: // urna em stand-by (lê os 6 digitos do numero de cartão)       
1128          //        
1129          //      
1130          //      case 2: // administrando votacao para senador (lê 2 digitos)
1131          
1132          
1133          //      case 3: // administrando votacao para governador (lê 2 digitos)
1134          
1135          
1136          //      case 4: // administrando votacao para presidente (lê 2 digitos)
1137          //    
1138          //      default:
1139          //        break;
1140          //    }
1141          //  } 
1142          //}
1143          
1144          
1145          //void estado_0(){
1146          //    if(OLU && hora<17 && hora>= 8)
1147          //        transicao_estado(1);  
1148          //}
1149          
1150          //void estado_1(){
1151          //    if(((hora>=17 || hora < 8) || !OLU) && estado != 0) 
1152          //      transicao_estado(0); //bloqueia a urna
1153          //}
1154          
1155          //void transicao_estado(char es){
1156          //  switch(es){
1157          //    case 0: //urna bloqueada
1158          //      clear_lcd();
1159          //      escreve_mensagem("Urna Bloqueada");
1160          //      estado = 0;
1161          //      break;
1162          //    case 1: //stand-by
1163          //      clear_lcd();
1164          //      escreve_mensagem("Digite o seu n de cartão:");
1165          //      estado = 1;
1166          //      break;
1167          //  }
1168          //}
1169          
1170          
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 20  

1171          //void transicao_estado(char et){
1172          //  
1173          //  switch(et){
1174          //  
1175          //  case 0: //urna bloqueada
1176          //  clear_lcd();
1177          //  escreve_mensagem("Urna Bloqueada");
1178          //  estado = 0;
1179          //  break;
1180          
1181          //  case 1: //stand-by
1182          //  clear_lcd();
1183          //  escreve_mensagem("Digite o seu n de cartão:");
1184          //  break;
1185          
1186          //  case 2: //votacao senador
1187          //  clear_lcd();
1188          //  escreve_mensagem("Digite o seu n de senador:");
1189          //  break;
1190          //  
1191          //  case 3: //votacao governador
1192          //  clear_lcd();
1193          //  escreve_mensagem("Digite o seu n de governador:");
1194          //  break;
1195          
1196          //  case 4: //votacao presidente
1197          //  clear_lcd();
1198          //  escreve_mensagem("Digite o seu n de presidente:");
1199          //  break;
1200          
1201          //  }
1202          
1203          //estado = et;
1204          
1205          //}
1206          
1207          
1208          
1209          
1210          /*
1211          
1212            c = le_teclado();
1213              if(c != 0){ 
1214              escreve_LCD(c);
1215              sound_buzzer_teclado(); 
1216              if(c == '*')
1217                  clear_lcd();
1218          
1219          
1220          char estado, FlagUrnaAutonoma
1221          short int cartao, ContTimeOutPc, ContTimeOutEleitor;
1222          char cartao_str[7], i;
1223          
1224          
1225          
1226          
1227          
1228          
1229          
1230          
1231          while(1){
1232          
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 21  

1233            if(((hora>=17 || hora < 8) || !OLE) && estado != 0) 
1234              transicao_estado(0); //bloqueia a urna
1235          
1236            switch(estado){
1237            
1238            case 0: //urna bloqueada
1239              if(OLE && hora<17 && hora>= 8)
1240                transicao_estado(1);  
1241              break;
1242          
1243            case 1: // urna em stand-by (lê os 6 digitos do numero de cartão)
1244              estado_1();
1245                  
1246              
1247            case 2: // administrando votacao para senador (lê 2 digitos)
1248          
1249          
1250            case 3: // administrando votacao para governador (lê 2 digitos)
1251          
1252          
1253            case 4: // administrando votacao para presidente (lê 2 digitos)
1254          
1255          
1256          
1257            }
1258          }
1259          
1260          
1261          
1262          
1263          char le_digito(char * d, n){
1264          //entrada: string a retornar os digitos, numero de digitos desejados
1265          //saida: 0, não terminou, fica no estado; 1, terminou, vai pro proximo estado; -1, cancela tudo e reinicia
             - o estado. 
1266          //entrada e saida: string q armazena os digitos (ponteiro)
1267          static i = 0;
1268          char digito;
1269          digito = le_teclado();
1270            if(digito != 0){
1271              if(digito != '#'){
1272              d[i] = digito;
1273              i++;
1274                if(i == n){
1275                i = 0;    
1276                return 1; //leitura completa
1277                }   
1278              } else {
1279              i = 0;
1280              return -1; //cancela a leitura 
1281              }
1282            }
1283          return 0; //continua a leitura
1284          }
1285          
1286          
1287          
1288          
1289          estado_1(){
1290          
1291          }
1292          
1293          
C51 COMPILER V9.51   MAIN                                                                  05/28/2018 10:09:17 PAGE 22  

1294          
1295            
1296          
1297          
1298          
1299          char adquire_digito(char* string, char n_digitos){
1300          //retorna 1 quando termina de ler os n digitos
1301          //retorna 0 se ainda nao terminou de ler
1302          //retorna -1 se o usuario deseja interromper a leitura
1303          //entrada: string a retornar os digitos, numero de digitos desejados
1304          //saida: 0, não terminou, fica no estado; 1, terminou, vai pro proximo estado; -1, cancela tudo e reinicia
             - o estado. 
1305          //entrada e saida: string q armazena os digitos (ponteiro)
1306          static i = 0;
1307          d[i] = le_teclado();
1308            if(d[i] != 0){
1309              if(digito != '#'){
1310                if(i <= n){ //enquanto i<n
1311                d[i] = digito;
1312                i++;
1313                escreve_LCD(d[i]);
1314                }else if(d[i] == '*'){ //espera a confirmação 
1315                  i = 0;    
1316                  return 1; //leitura completa
1317                  }
1318                }   
1319              
1320              } else {
1321              i = 0;
1322              return -1; //cancela a leitura 
1323              }
1324            }
1325          return 0; //continua a leitura
1326          }
1327          
1328          
1329          short int converte_string_int(char* string){
1330          char i;
1331          short int r = 0;
1332          for(i=0; string != 0; i++)
1333            r = r + (string[i] - '0')*i;
1334          return r
1335          }
1336          
1337          
1338          
1339          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3342    ----
   CONSTANT SIZE    =    232    ----
   XDATA SIZE       =    870    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     59      90
   IDATA SIZE       =     30    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
