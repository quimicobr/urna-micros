C51 COMPILER V9.56.0.0   SERIAL                                                            05/21/2018 16:25:11 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE SERIAL
OBJECT MODULE PLACED IN .\Objects\serial.obj
COMPILER INVOKED BY: C:\Keil_v5_C51\C51\BIN\C51.EXE serial.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\serial.lst) TABS(2) OBJECT(.\Objects\serial.obj)

line level    source

   1          #include<serial.h>
   2          #include<lcd.h>
   3          #include<reg52.h>
   4          #include<myString.h>
   5          
   6          //0   EXTERNAL INT 0  0003h
   7          //1   TIMER/COUNTER 0   000Bh
   8          //2   EXTERNAL INT 1  0013h
   9          //3   TIMER/COUNTER 1   001Bh
  10          //4   SERIAL PORT   0023h
  11          //5   TIMER/COUNTER 2 (8052)  002Bh
  12          
  13          #define NORMAL 0
  14          #define BLOQUEADA 1
  15          #define AUTONOMA 2 
  16          
  17          #define OK 0
  18          #define PE 1
  19          #define PC 2 
  20          #define PT 3
  21          #define PS 4
  22          #define PG 5 
  23          #define PP 6 
  24          
  25          char fifo_recepcao[30];
  26          
  27          void configura_serial(){
  28   1        //configura o timer 1
  29   1        TMOD &= 0x0F;
  30   1        TMOD |= 0x20; //timer de 8 bits com recarga automática
  31   1        TL1 = 0xFD; //19200 bps
  32   1        TH1 = 0xFD; //recarga
  33   1        TR1 = 1; //liga o timer
  34   1        //configura a serial
  35   1        SCON = 0x50; //serial com freq variável + habilita recepcao
  36   1        EA = 1; //habilita as interrrupcoes do chip
  37   1        ES = 1; //habilita interrupcao da serial
  38   1      }
  39          
  40          void escreve_serial(char* mensagem){
  41   1      char i;
  42   1        for(i = 0; mensagem[i] != 0 ; i++){
  43   2          SBUF = mensagem[i];
  44   2          while(!TI);
  45   2          TI=0;
  46   2        }
  47   1      }
  48          
  49          void clear_FIFO(){
  50   1        char i;
  51   1        for (i = 0; fifo_recepcao[i] != '\0' && i<30; i++) fifo_recepcao[i] = '\0';
  52   1        
  53   1      }
  54          
C51 COMPILER V9.56.0.0   SERIAL                                                            05/21/2018 16:25:11 PAGE 2   

  55          
  56          
  57          void trata_interrupcao_serial() interrupt 4 { 
  58   1        static char is = 0;
  59   1        if(RI == 1){
  60   2          RI = 0;
  61   2          fifo_recepcao[is] = SBUF;
  62   2          is++;
  63   2          if (trata_dados()){
  64   3            clear_FIFO();
  65   3            is = 0;     
  66   3          }
  67   2        }
  68   1      }
  69          
  70          //No momento, a confirmação é enviada assim que o computador envia o comando
  71          //O 
  72          char trata_dados(){
  73   1        
  74   1        //Libera urna
  75   1        if (fifo_recepcao[0] == 'P' && fifo_recepcao[1] == 'L'){
  76   2          OLU = 1; //Ordem de Liberar Urna 
  77   2          escreve_serial("ML");
  78   2          return 1;
  79   2        }
  80   1        
  81   1        //Bloqueia urna
  82   1        if (fifo_recepcao[0] == 'P' && fifo_recepcao[1] == 'B'){
  83   2          OLU = 0; //Ordem de Liberar Urna
  84   2          escreve_serial("MB");
  85   2          return 1;
  86   2        }
  87   1        
  88   1        //Atualiza o horario
  89   1        if (fifo_recepcao[0] == 'P' && fifo_recepcao[1] == 'H'){
  90   2          
  91   2          minuto = fifo_recepcao[3];
  92   2          hora = fifo_recepcao[2];
  93   2          escreve_serial("MH");
  94   2          return 1;
  95   2          
  96   2        }
  97   1        
  98   1        if (fifo_recepcao[0] == 'P' && fifo_recepcao[1] == 'U'){
  99   2          //Envia boletim de urna
 100   2          
 101   2        }
 102   1        
 103   1        if (fifo_recepcao[0] == 'P' && fifo_recepcao[1] == 'E'){
 104   2          //Confirma entrada do eleitor
 105   2          if (respostaPC == PE){
 106   3            respostaPC = OK;
 107   3          }
 108   2          return 1;
 109   2        }
 110   1        
 111   1        if (fifo_recepcao[0] == 'P' && fifo_recepcao[1] == 'C'){  
 112   2          //Confirma conclusão do voto
 113   2          if (respostaPC == PC){
 114   3            respostaPC = OK;
 115   3          }
 116   2          return 1;
C51 COMPILER V9.56.0.0   SERIAL                                                            05/21/2018 16:25:11 PAGE 3   

 117   2        }
 118   1        
 119   1        if (fifo_recepcao[0] == 'P' && fifo_recepcao[1] == 'T'){
 120   2          //Confirma timeout do eleitor
 121   2          if (respostaPC == PT){
 122   3            respostaPC = OK;
 123   3          }
 124   2          return 1;
 125   2        }
 126   1        
 127   1        if (fifo_recepcao[0] == 'P' && fifo_recepcao[1] == 'S'){
 128   2          //Confirma envio do nome de senador
 129   2          if (respostaPC == PS){
 130   3            escreve_mensagem(fifo_recepcao);
 131   3            copia_string(pacote, fifo_recepcao);
 132   3            respostaPC = OK;
 133   3          }
 134   2          return 1;
 135   2        }
 136   1        
 137   1        if (fifo_recepcao[0] == 'P' && fifo_recepcao[1] == 'G'){
 138   2          //Confirma envio do nome de governador
 139   2          if (respostaPC == PG){
 140   3            copia_string(pacote, fifo_recepcao);
 141   3            respostaPC = OK;
 142   3          }
 143   2          return 1;
 144   2        }
 145   1        
 146   1        if (fifo_recepcao[0] == 'P' && fifo_recepcao[1] == 'P'){
 147   2          //Confirma envio do nome de presidente
 148   2          if (respostaPC == PP){
 149   3            copia_string(pacote, fifo_recepcao);
 150   3            respostaPC = OK;
 151   3          }
 152   2          return 1;
 153   2        }
 154   1        return 0;
 155   1      }
 156          
 157          void solicita_senador(char* codigo){
 158   1        
 159   1        char mensagem[6];
 160   1        mensagem[0] = 'M';
 161   1        mensagem[1] = 'S';
 162   1        mensagem[2] = 2;
 163   1        mensagem[3] = codigo[0];
 164   1        mensagem[4] = codigo[1];
 165   1        mensagem[5] = '\0';
 166   1        respostaPC = PS;
 167   1        escreve_serial(mensagem);
 168   1        
 169   1      }
 170          
 171          void solicita_governador(char* codigo){
 172   1        
 173   1        char mensagem[6];
 174   1        mensagem[0] = 'M';
 175   1        mensagem[1] = 'G';
 176   1        mensagem[2] = 2;
 177   1        mensagem[3] = codigo[0];
 178   1        mensagem[4] = codigo[1];
C51 COMPILER V9.56.0.0   SERIAL                                                            05/21/2018 16:25:11 PAGE 4   

 179   1        mensagem[5] = '\0';
 180   1        respostaPC = PG;
 181   1        escreve_serial(mensagem);
 182   1      }
 183          
 184          void solicita_presidente(char* codigo){
 185   1        
 186   1        char mensagem[6];
 187   1        mensagem[0] = 'M';
 188   1        mensagem[1] = 'P';
 189   1        mensagem[2] = 2;
 190   1        mensagem[3] = codigo[0];
 191   1        mensagem[4] = codigo[1];
 192   1        mensagem[5] = '\0';
 193   1        respostaPC = PP;
 194   1        escreve_serial(mensagem);
 195   1      }
 196          
 197          
 198          
 199          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    542    ----
   CONSTANT SIZE    =      9    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     31      21
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
