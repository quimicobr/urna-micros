C51 COMPILER V9.56.0.0   CODIGO_MAIN                                                       05/21/2018 16:25:10 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE CODIGO_MAIN
OBJECT MODULE PLACED IN .\Objects\codigo_main.obj
COMPILER INVOKED BY: C:\Keil_v5_C51\C51\BIN\C51.EXE codigo_main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\codigo_main.lst) TABS(2) OBJECT(.\Objects\codigo_main.obj)

line level    source

   1          #include<reg52.h>
   2          #include<lcd.h>
   3          #include<teclado.h>
   4          #include<serial.h>
   5          //#include<relogio.h>
   6          #include<myString.h>
   7          
   8          
   9          //TIMER0: uso geral (atraso,...)
  10          //TIMER1: exclusivo da serial
  11          //TIMER2: exclusivo do relógio
  12          
  13          
  14          
  15          char estado;
  16          #define NORMAL 0
  17          #define BLOQUEADA 1
  18          #define AUTONOMA 2 
  19          
  20          //Variaveis onde estará registrada a hora
  21          char hora = 0;
  22          char minuto = 0;
  23          char segundo = 0;
  24          char OLU = 0;
  25          
  26          // -- Flag que indica se o microcontrolador está esperando uma resposta do PC
  27          //No  momento que o microcontrolador envia um comando que precisa de resposta
  28          //essa flag é setada para 0. No momento que o computador responde, a flag
  29          //é setada para 1.
  30          char respostaPC;
  31          #define OK 0
  32          #define PE 1
  33          #define PC 2 
  34          #define PT 3
  35          #define PS 4
  36          #define PG 5 
  37          #define PP 6 
  38          
  39          idata char pacote[30];
  40          
  41          sbit BUZZER = P3^3;
  42          
  43          void clear_pacote(){
  44   1        
  45   1        char i;
  46   1        for (i = 0; pacote[i] != '\0' && i<30; i++){
  47   2          pacote[i] = '\0';
  48   2        }
  49   1          
  50   1        
  51   1      }
  52          
  53          void configura_serial();
  54          
C51 COMPILER V9.56.0.0   CODIGO_MAIN                                                       05/21/2018 16:25:10 PAGE 2   

  55            xdata struct {
  56            
  57            char nome[20];
  58            char partido[5];
  59            char nPartido[3];
  60            unsigned char nVotos;
  61            
  62            }presidente[10], governador[10], senador[10];
  63          
  64          short code codigo_eleitor [] = {262659, 206603, 244444, 216628, 
  65                262645,
  66                208221,
  67                262668,
  68                230357,
  69                262672,
  70                143293,
  71                245562,
  72                262686,
  73                264768,
  74                161948,
  75                262649,
  76                231423,
  77                230340,
  78                195149,
  79                231023,
  80                231035,
  81                221689,
  82                220149,
  83                264770,
  84                216625,
  85                262670,
  86                180669,
  87                262688,
  88                186103,
  89                230230,
  90                219839,
  91                243704,
  92                243716,
  93                275628,
  94                262543,
  95                275632,
  96                275631,
  97                275629,
  98                221433,
  99                262542,
 100                275633,
 101                218776,
 102                216149,
 103                262539,
 104                207273,
 105                259797 };
 106            
 107            
 108          //Como vai funcionar: a urna tem que estar em modo standby para receber algo do teclado ou da serial.
 109          //Se ela está em modo bloqueada, ela não pode estar disponível para receber nada do teclado.
 110          //Se ela está em modo
 111          
 112          
 113          //Inicialização: configurar serial, relógio, LCD e pedir os dados de todos os candidatos possíveis 
 114          
 115          void varredura_candidatos(){
 116   1        
C51 COMPILER V9.56.0.0   CODIGO_MAIN                                                       05/21/2018 16:25:10 PAGE 3   

 117   1        char d0, d1;
 118   1        char d[3];
 119   1        char comprimento, i, inicio_par;
 120   1        char nome[20];
 121   1        char partido[5];
 122   1        char pos_sen = 0, pos_gov = 0, pos_pres = 0;
 123   1      
 124   1        for (d0 = '0'; d0 <= '1'; d0++){
 125   2          
 126   2          d[0] = d0;
 127   2          for (d1 = '0'; d1 <= '9'; d1++){
 128   3            
 129   3            d[1] = d1;
 130   3            d[2] = '\0';
 131   3            // ---------------------------
 132   3            solicita_senador(d);
 133   3            while (respostaPC != OK);
 134   3            //Pega o dado do senador e ve se nao é nulo
 135   3            //Se não for, armazena no vetor de struct
 136   3            
 137   3            comprimento = pacote[2];
 138   3            
 139   3            for (i = 0; pacote[i+3] != ' ' ; i++){
 140   4              nome[i] = pacote[i+3];
 141   4            }
 142   3            inicio_par = i + 1; 
 143   3            for (i = 0; pacote[i+inicio_par] != '\0'; i++){
 144   4              partido[i] = pacote[i+inicio_par];
 145   4            }
 146   3            
 147   3            
 148   3            if(!compara_string(nome,"NULO")){
 149   4              copia_string(senador[pos_sen].nome, nome);
 150   4              copia_string(senador[pos_sen].partido, partido);
 151   4              copia_string(senador[pos_sen].nPartido, d);
 152   4            }
 153   3            clear_string(pacote);
 154   3            clear_string(nome);
 155   3            clear_string(partido);
 156   3            // ---------------------------
 157   3            solicita_governador(d);
 158   3            
 159   3            while (respostaPC != OK);
 160   3            //Pega o dado do senador e ve se nao é nulo
 161   3            //Se não for, armazena no vetor de struct
 162   3            comprimento = pacote[2];
 163   3            
 164   3            for (i = 0; pacote[i+3] != ' '; i++){
 165   4              nome[i] = pacote[i+3];
 166   4            }
 167   3            inicio_par = i + 1; 
 168   3            for (i = 0; pacote[i+inicio_par] != '\0'; i++){
 169   4              partido[i] = pacote[i+inicio_par];
 170   4            }
 171   3            
 172   3            clear_pacote();
 173   3            
 174   3            if(!compara_string(nome,"NULO")){
 175   4              copia_string(governador[pos_sen].nome, nome);
 176   4              copia_string(governador[pos_sen].partido, partido);
 177   4              copia_string(governador[pos_sen].nPartido, d);
 178   4            }
C51 COMPILER V9.56.0.0   CODIGO_MAIN                                                       05/21/2018 16:25:10 PAGE 4   

 179   3            
 180   3            // ---------------------------
 181   3            solicita_presidente(d);
 182   3            
 183   3            while (respostaPC != OK);
 184   3            //Pega o dado do senador e ve se nao é nulo
 185   3            //Se não for, armazena no vetor de struct
 186   3            comprimento = pacote[2];
 187   3            
 188   3            for (i = 0; pacote[i+3] != ' '; i++){
 189   4              nome[i] = pacote[i+3];
 190   4            }
 191   3            inicio_par = i + 1; 
 192   3            for (i = 0; pacote[i+inicio_par] != '\0'; i++){
 193   4              partido[i] = pacote[i+inicio_par];
 194   4            }
 195   3            
 196   3            clear_pacote();
 197   3            
 198   3            if(!compara_string(nome,"NULO")){
 199   4              copia_string(presidente[pos_sen].nome, nome);
 200   4              copia_string(presidente[pos_sen].partido, partido);
 201   4              copia_string(presidente[pos_sen].nPartido, d);
 202   4            }
 203   3      
 204   3          } 
 205   2        }
 206   1      }
 207          
 208          void main(){
 209   1          //Configura a porta serial
 210   1        configura_serial();
 211   1        
 212   1        //Configura o relogio
 213   1      //  configura_relogio();
 214   1        
 215   1        //Inicializa o visor LCD
 216   1        LCD_init();
 217   1      
 218   1        escreve_serial("Incixializa");
 219   1        varredura_candidatos();
 220   1        
 221   1        
 222   1        while(1){
 223   2      
 224   2            
 225   2          
 226   2        }
 227   1          
 228   1      }
 229          
 230          
 231          
 232          
 233          
 234          
 235          
 236          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    772    ----
C51 COMPILER V9.56.0.0   CODIGO_MAIN                                                       05/21/2018 16:25:10 PAGE 5   

   CONSTANT SIZE    =    107    ----
   XDATA SIZE       =    870    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6      36
   IDATA SIZE       =     30    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
