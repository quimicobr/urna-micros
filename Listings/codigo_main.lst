C51 COMPILER V9.55   CODIGO_MAIN                                                           05/23/2018 13:57:11 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE CODIGO_MAIN
OBJECT MODULE PLACED IN .\Objects\codigo_main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE codigo_main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\codigo_main.lst) TABS(2) OBJECT(.\Objects\codigo_main.obj)

line level    source

   1          #include<reg52.h>
   2          #include<lcd.h>
   3          #include<teclado.h>
   4          #include<serial.h>
   5          #include<relogio.h>
   6          #include<myString.h>
   7          #include<buzzer.h>
   8          
   9          
  10          //TIMER0: uso geral (atraso,...)
  11          //TIMER1: exclusivo da serial
  12          //TIMER2: exclusivo do relógio
  13          
  14          
  15          
  16          char estado;
  17          #define NORMAL 0
  18          #define BLOQUEADA 1
  19          #define AUTONOMA 2 
  20          
  21          //Variaveis onde estará registrada a hora
  22          char hora = 0;
  23          char minuto = 0;
  24          char segundo = 0;
  25          char OLU = 0;
  26          
  27          // -- Flag que indica se o microcontrolador está esperando uma resposta do PC
  28          //No  momento que o microcontrolador envia um comando que precisa de resposta
  29          //essa flag é setada para 0. No momento que o computador responde, a flag
  30          //é setada para 1.
  31          char respostaPC;
  32          #define OK 0
  33          #define PE 1
  34          #define PC 2 
  35          #define PT 3
  36          #define PS 4
  37          #define PG 5 
  38          #define PP 6 
  39          
  40          idata char pacote[30];
  41          
  42          
  43          
  44          void clear_pacote(){
  45   1        
  46   1        char i;
  47   1        for (i = 0; pacote[i] != '\0' && i<30; i++){
  48   2          pacote[i] = '\0';
  49   2        }
  50   1          
  51   1      }
  52          
  53          void configura_serial();
  54          
C51 COMPILER V9.55   CODIGO_MAIN                                                           05/23/2018 13:57:11 PAGE 2   

  55            xdata struct {
  56            
  57            char nome[20];
  58            char partido[5];
  59            char nPartido[3];
  60            unsigned char nVotos;
  61            
  62            }presidente[10], governador[10], senador[10];
  63          
  64          short code codigo_eleitor [] = {262659, 206603, 244444, 216628, 
  65                262645,
  66                208221,
  67                262668,
  68                230357,
  69                262672,
  70                143293,
  71                245562,
  72                262686,
  73                264768,
  74                161948,
  75                262649,
  76                231423,
  77                230340,
  78                195149,
  79                231023,
  80                231035,
  81                221689,
  82                220149,
  83                264770,
  84                216625,
  85                262670,
  86                180669,
  87                262688,
  88                186103,
  89                230230,
  90                219839,
  91                243704,
  92                243716,
  93                275628,
  94                262543,
  95                275632,
  96                275631,
  97                275629,
  98                221433,
  99                262542,
 100                275633,
 101                218776,
 102                216149,
 103                262539,
 104                207273,
 105                259797 };
 106            
 107            
 108          //Como vai funcionar: a urna tem que estar em modo standby para receber algo do teclado ou da serial.
 109          //Se ela está em modo bloqueada, ela não pode estar disponível para receber nada do teclado.
 110          //Se ela está em modo
 111          
 112          
 113          //Inicialização: configurar serial, relógio, LCD e pedir os dados de todos os candidatos possíveis 
 114          
 115          /*void varredura_candidatos(){
 116            
C51 COMPILER V9.55   CODIGO_MAIN                                                           05/23/2018 13:57:11 PAGE 3   

 117            char d0, d1;
 118            char d[3];
 119            char comprimento, i, inicio_par;
 120            char nome[20];
 121            char partido[5];
 122            char pos_sen = 0, pos_gov = 0, pos_pres = 0;
 123          
 124            for (d0 = '0'; d0 <= '1'; d0++){
 125              
 126              d[0] = d0;
 127              for (d1 = '0'; d1 <= '9'; d1++){
 128                
 129                d[1] = d1;
 130                d[2] = '\0';
 131                // ---------------------------
 132                solicita_senador(d);
 133                while (respostaPC != OK);
 134                //Pega o dado do senador e ve se nao é nulo
 135                //Se não for, armazena no vetor de struct
 136                
 137                comprimento = pacote[2];
 138                
 139                for (i = 0; pacote[i+3] != ' ' ; i++){
 140                  nome[i] = pacote[i+3];
 141                }
 142                inicio_par = i + 1; 
 143                for (i = 0; pacote[i+inicio_par] != '\0'; i++){
 144                  partido[i] = pacote[i+inicio_par];
 145                }
 146                
 147                
 148                if(!compara_string(nome,"NULO")){
 149                  copia_string(senador[pos_sen].nome, nome);
 150                  copia_string(senador[pos_sen].partido, partido);
 151                  copia_string(senador[pos_sen].nPartido, d);
 152                }
 153                clear_string(pacote);
 154                clear_string(nome);
 155                clear_string(partido);
 156                // ---------------------------
 157                solicita_governador(d);
 158                
 159                while (respostaPC != OK);
 160                //Pega o dado do senador e ve se nao é nulo
 161                //Se não for, armazena no vetor de struct
 162                comprimento = pacote[2];
 163                
 164                for (i = 0; pacote[i+3] != ' '; i++){
 165                  nome[i] = pacote[i+3];
 166                }
 167                inicio_par = i + 1; 
 168                for (i = 0; pacote[i+inicio_par] != '\0'; i++){
 169                  partido[i] = pacote[i+inicio_par];
 170                }
 171                
 172                clear_pacote();
 173                
 174                if(!compara_string(nome,"NULO")){
 175                  copia_string(governador[pos_sen].nome, nome);
 176                  copia_string(governador[pos_sen].partido, partido);
 177                  copia_string(governador[pos_sen].nPartido, d);
 178                }
C51 COMPILER V9.55   CODIGO_MAIN                                                           05/23/2018 13:57:11 PAGE 4   

 179                
 180                // ---------------------------
 181                solicita_presidente(d);
 182                
 183                while (respostaPC != OK);
 184                //Pega o dado do senador e ve se nao é nulo
 185                //Se não for, armazena no vetor de struct
 186                comprimento = pacote[2];
 187                
 188                for (i = 0; pacote[i+3] != ' '; i++){
 189                  nome[i] = pacote[i+3];
 190                }
 191                inicio_par = i + 1; 
 192                for (i = 0; pacote[i+inicio_par] != '\0'; i++){
 193                  partido[i] = pacote[i+inicio_par];
 194                }
 195                
 196                clear_pacote();
 197                
 198                if(!compara_string(nome,"NULO")){
 199                  copia_string(presidente[pos_sen].nome, nome);
 200                  copia_string(presidente[pos_sen].partido, partido);
 201                  copia_string(presidente[pos_sen].nPartido, d);
 202                }
 203          
 204              } 
 205            }
 206          }*/
 207          /*
 208          void envia_boletim(){
 209            
 210            char i;
 211            char votos[3];
 212            
 213            for (i = 0; i<10; i++){
 214              
 215              
 216              escreve_serial("Senador: {");
 217              
 218              if(compara_string(senador[i].nome, "")){
 219                
 220                escreve_serial("(");
 221                escreve_serial(senador[i].nome);
 222                escreve_serial(",");
 223                number_to_char(votos,senador[i].nVotos);
 224                escreve_serial(votos);
 225                escreve_serial(") ");
 226                
 227              }
 228              
 229              escreve_serial("} Governador: {");
 230              
 231              if(compara_string(governador[i].nome, "")){
 232                
 233                escreve_serial("(");
 234                escreve_serial(governador[i].nome);
 235                escreve_serial(",");
 236                number_to_char(votos,governador[i].nVotos);
 237                escreve_serial(votos);
 238                escreve_serial(") ");
 239                
 240              }
C51 COMPILER V9.55   CODIGO_MAIN                                                           05/23/2018 13:57:11 PAGE 5   

 241              
 242              escreve_serial("} Presidente: {");
 243              
 244              if(compara_string(presidente[i].nome, "")){
 245                
 246                escreve_serial("(");
 247                escreve_serial(presidente[i].nome);
 248                escreve_serial(",");
 249                number_to_char(votos,presidente[i].nVotos);
 250                escreve_serial(votos);
 251                escreve_serial(") ");
 252                
 253              }
 254              
 255              escreve_serial("}");
 256            }
 257          }
 258          *//*
 259          void inicializa_structs(){
 260            
 261            char i;
 262            for(i = 0; i<10; i++){
 263              
 264              inicializa_string(senador[i].nome, 20);
 265              inicializa_string(senador[i].partido, 5);
 266              inicializa_string(senador[i].nPartido, 3);
 267              senador[i].nVotos = 0;
 268              
 269              inicializa_string(governador[i].nome, 20);
 270              inicializa_string(governador[i].partido, 5);
 271              inicializa_string(governador[i].nPartido, 3);
 272              governador[i].nVotos = 0;
 273              
 274              inicializa_string(presidente[i].nome, 20);
 275              inicializa_string(presidente[i].partido, 5);
 276              inicializa_string(presidente[i].nPartido, 3);
 277              presidente[i].nVotos = 0;
 278              
 279            }
 280            
 281          }*/
 282          
 283          void main(){
 284   1        char c;
 285   1        
 286   1        configura_serial();
 287   1        configura_relogio();
 288   1        
 289   1        //Inicializa o visor LCD
 290   1        LCD_init();
 291   1      
 292   1        //inicializa_structs();
 293   1          //clear_pacote();
 294   1          //solicita_senador("13");
 295   1        
 296   1        while(1){
 297   2          
 298   2          c = le_teclado();
 299   2          
 300   2        } 
 301   1      }
 302          
C51 COMPILER V9.55   CODIGO_MAIN                                                           05/23/2018 13:57:11 PAGE 6   

 303          
 304          
 305          
 306          
 307          
 308          
 309          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     43    ----
   CONSTANT SIZE    =     90    ----
   XDATA SIZE       =    870    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6       1
   IDATA SIZE       =     30    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
